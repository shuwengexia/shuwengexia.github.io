[{"title":"CAN过滤器的基础知识","url":"/2023/01/12/CAN%E8%BF%87%E6%BB%A4%E5%99%A8%E7%9A%84%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/","content":"CAN过滤器过滤器\nSTM32的bxCAN接收时必须使用过滤器接收\n根据CAN外设数量的不同有以下情况：\n只有CAN1：CAN1有14个过滤器\n有CAN1和CAN2：CAN1和CAN2共享28个过滤器\n有CAN1~3：CAN1和CAN2共享28个过滤器，CAN3有独立的14个过滤器\n\n\n过滤器可以过滤CAN总线上帧的ID号\n可以不处理不想接收的ID号，只接收想要的ID号\n\n\n\n过滤器的过滤模式\n过滤器总长度64位，可以分为2个32位单元或4个16位单元\n两种过滤模式：掩码和列表\n掩码模式：由两个单元组成通过掩码匹配\n列表模式：由一个单元组成，ID号完全匹配即通过\n\n\nID号对齐最高位（MSB）\n仅32位单元可以过滤拓展ID\n在列表模式下，scale为32时，每个过滤器的列表只能写入两个报文ID，若scale为16时，每个过滤器的列表最多可写入4个CAN ID\n\n\n掩码（不常用掩码模式）\n两个单元分别组成匹配ID和掩码（MASK）\n\n被过滤的ID号和匹配ID号会和掩码进行按位与运算后再进行匹配\n\n也就是只有对应的掩码为1的位才会被匹配\n\n\n例如：\n\n匹配ID为0x200，掩码为0x000，则所有ID号都能通过\n匹配ID为0x200，掩码为0x700，则ID为0x200~0x2FF均可通过\n匹配ID为0x200，掩码为0x7FF，则只有0x200能通过\n\n\n可以指定一个ID号的范围，在这个范围内的ID号可以通过我们的过滤器\n过滤器一共有4种工作模式：\n32位宽的掩码模式，  配置过滤2个不同的ID号32位宽的列表模式，  配置过滤4个不同的ID号16位宽的列表模式，  配置过滤2个不同的ID号16位宽的掩码模式    配置过滤1个不同的ID号\n\n过滤器的位宽:\n16位过滤器32位过滤器\n\nCAN的双接收中断\n每个CAN有两个接收中断，对应两组接收邮箱（FIFO）\n每个过滤器可以绑定一个CAN接收中断\n经过过滤器过滤的帧会进入该过滤器绑定的接收中断对应的邮箱\n匹配时，列表模式的优先级高于掩码模式，其次过滤器编号更小的优先级更高\n\n使用CAN2过滤ID号（实验）\nCAN1给CAN2发送不同ID号的数据帧\nCAN2使用过滤器进行过滤\nRX0和RX1分别对应不同过滤器，接收到不同数组中\n\n在之前CAN实验的代码上修改\n这里我们只需要修改CAN2，把CAN_Configfilter()函数中的sFiterconfig拷贝下来\n覆盖掉之前的sFiterconfig.FilterBank\nsFiterconfig.FilterActivation = CAN_FILTER_ENABLE;//激活过滤器sFiterconfig.FilterBank=0;//过滤器编号，CAN1是0~13sFiterconfig.FilterFIFOAssignment=CAN_FILTER_FIFO0;sFiterconfig.FilterMode=CAN_FILTERMODE_IDMASK;//设置为掩码模式sFiterconfig.FilterScale=CAN_FILTERSCALE_32BIT;//设置为32位宽sFiterconfig.FilterIdHigh=0x0000;//设置验证码sFiterconfig.FilterIdLow=0x0000;sFiterconfig.FilterMaskIdHigh=0x0000;sFiterconfig.FilterMaskIdLow=0x0000;sFiterconfig.SlaveStartFilterBank=14;\n\n\n列表模式\n绑定FIFO0\n\n\n把下面的FilterBank设置为14，FilterMode改为CAN_FILTERMODE_IDLIST，FilterScale改为CAN_FILTERSCALE_16BIT，下面的ID号改为我们需要的ID号，这里我们可以设为0x200左移5位(左移5是为了对齐msb)\nsFiterconfig.FilterActivation = CAN_FILTER_ENABLE;sFiterconfig.FilterBank=14;//过滤器编号，CAN2是14~27sFiterconfig.FilterFIFOAssignment=CAN_FILTER_FIFO0;//接收到的报文放入到FIFO0中sFiterconfig.FilterMode=CAN_FILTERMODE_IDLIST;//列表模式sFiterconfig.FilterScale=CAN_FILTERSCALE_32BIT;//设置32位宽sFiterconfig.FilterIdHigh=0x200&lt;&lt;5;//基本ID放入到STID中  sFiterconfig.FilterIdLow=0x201&lt;&lt;5;sFiterconfig.FilterMaskIdHigh=0x202&lt;&lt;5;//设置为0时，表示不过滤，可以接收任意的CANID数据，sFiterconfig.FilterMaskIdLow=0x203&lt;&lt;5;//不为0时，则表示过滤 对应MaskID为1的bit必须与FilterID中的bit位相同的CANID才能接收过来。sFiterconfig.SlaveStartFilterBank=14;\n\n\n掩码模式\n绑定FIFO1\n\n\n在HAL库中FilterIdHigh，FilterIdLow，FilterMaskIdHigh，FilterMaskIdLow\n\nFilterBank是过滤器编号，为了避免重复，这里设置为15，FilterMode选择CAN_FILTERMODE_IDMASK，因为我们这里过滤标准帧，没必要使用32位，所以FilterScale选择16位，FilterIdHigh，FilterIdLow在16位模式下指代两个不同的掩码组，FilterIdHigh对应FilterMaskIdHigh，FilterIdLow对应FilterMaskIdLow，一共是两组；如果是32位，就要把他们整个拼成一段整体，因此这里我们需要把它们拼成两组\nsFiterconfig.FilterActivation = CAN_FILTER_ENABLE;sFiterconfig.FilterBank=15;//过滤器编号，CAN2是14~27sFiterconfig.FilterFIFOAssignment=CAN_FILTER_FIFO1;sFiterconfig.FilterMode=CAN_FILTERMODE_IDLIST;sFiterconfig.FilterScale=CAN_FILTERSCALE_16BIT;sFiterconfig.FilterIdHigh=0x200&lt;&lt;5;//ID和掩码都要移5位sFiterconfig.FilterMaskIdHigh=0x202&lt;&lt;5;sFiterconfig.FilterIdLow=0x201&lt;&lt;5;sFiterconfig.FilterMaskIdLow=0x203&lt;&lt;5;sFiterconfig.SlaveStartFilterBank=14;\n\n把FilterMaskIdHigh设置为0x700，这样就表示过滤0x200到0x2FF的ID号\n把FilterMaskIdHigh设置为0x7F0，这样就表示过滤0x200到0x20F的ID号\n这里我们设置为0x7F0，更方便我们观察现象\n然后把FilterFIFOAssignment改为CAN_FILTER_FIFO1，即绑定FIFO1，对应RX1的中断，这样就完成了掩码模式的配置\n最终CAN_Configfilter()代码如下：\n/* USER CODE BEGIN 4 */void CAN_Configfilter()&#123;  CAN_FilterTypeDef sFiterconfig;  sFiterconfig.FilterActivation = CAN_FILTER_ENABLE;  sFiterconfig.FilterBank=0;  sFiterconfig.FilterFIFOAssignment=CAN_FILTER_FIFO0;  sFiterconfig.FilterMode=CAN_FILTERMODE_IDMASK;  sFiterconfig.FilterScale=CAN_FILTERSCALE_32BIT;  sFiterconfig.FilterIdHigh=0x0000;  sFiterconfig.FilterIdLow=0x0000;  sFiterconfig.FilterMaskIdHigh=0x0000;  sFiterconfig.FilterMaskIdLow=0x0000;  sFiterconfig.SlaveStartFilterBank=14;  if( HAL_CAN_ConfigFilter(&amp;hcan1,&amp;sFiterconfig)!=HAL_OK)  &#123;    Error_Handler();  &#125; //列表模式  sFiterconfig.FilterActivation = CAN_FILTER_ENABLE;  sFiterconfig.FilterBank=14;  sFiterconfig.FilterFIFOAssignment=CAN_FILTER_FIFO0;  sFiterconfig.FilterMode=CAN_FILTERMODE_IDLIST;  sFiterconfig.FilterScale=CAN_FILTERSCALE_16BIT;  sFiterconfig.FilterIdHigh=0x200&lt;&lt;5;  sFiterconfig.FilterIdLow=0x201&lt;&lt;5;  sFiterconfig.FilterMaskIdHigh=0x202&lt;&lt;5;  sFiterconfig.FilterMaskIdLow=0x203&lt;&lt;5;  sFiterconfig.SlaveStartFilterBank=14;  if( HAL_CAN_ConfigFilter(&amp;hcan2,&amp;sFiterconfig)!=HAL_OK)  &#123;    Error_Handler();  &#125;  //掩码模式  sFiterconfig.FilterActivation = CAN_FILTER_ENABLE;  sFiterconfig.FilterBank=15;  sFiterconfig.FilterFIFOAssignment=CAN_FILTER_FIFO0;  sFiterconfig.FilterMode=CAN_FILTERMODE_IDMASK;  sFiterconfig.FilterScale=CAN_FILTERSCALE_16BIT;  sFiterconfig.FilterIdHigh=0x200&lt;&lt;5;  sFiterconfig.FilterIdLow=0x201&lt;&lt;5;  sFiterconfig.FilterMaskIdHigh=0x202&lt;&lt;5;  sFiterconfig.FilterMaskIdLow=0x203&lt;&lt;5;  sFiterconfig.SlaveStartFilterBank=14;  if(HAL_CAN_Start(&amp;hcan1)!=HAL_OK)  &#123;    Error_Handler();  &#125;  if(HAL_CAN_Start(&amp;hcan2)!=HAL_OK)  &#123;    Error_Handler();  &#125;  if(HAL_CAN_ActivateNotification(&amp;hcan1,CAN_IT_RX_FIFO0_MSG_PENDING | CAN_IT_RX_FIFO1_MSG_PENDING!=HAL_OK))  &#123;    Error_Handler();  &#125;    if(HAL_CAN_ActivateNotification(&amp;hcan2,CAN_IT_RX_FIFO0_MSG_PENDING | CAN_IT_RX_FIFO1_MSG_PENDING!=HAL_OK))  &#123;    Error_Handler();  &#125;&#125;void HAL_can_RxFifo0MsgPendingCallback(CAN_HandleTypeDef*hcan)//接收数据的回调函数&#123;  if(hcan==&amp;hcan2)  &#123;    HAL_CAN_GetRxMessage(&amp;hcan2,CAN_RX_FIFO0,&amp;rxHeader0,rxDateBuffer0);  &#125;&#125;//RX0void HAL_can_RxFifo1MsgPendingCallback(CAN_HandleTypeDef*hcan)//接收数据的回调函数&#123;    if(hcan==&amp;hcan2)  &#123;    HAL_CAN_GetRxMessage(&amp;hcan2,CAN_RX_FIFO1,&amp;rxHeader1,rxDateBuffer1);  &#125;&#125;//RX1/* USER CODE END 4 */\n\n然后就可以编译烧录。\n","tags":["嵌入式学习"]},{"title":"Test","url":"/2023/01/11/test/","content":"这是一个测试文档\n","tags":["test"]},{"title":"初识IIC","url":"/2023/02/10/%E5%88%9D%E8%AF%86IIC/","content":"IIC总线IIC总线简介IIC总线是Philips公司在八十年代初推出的一种串行、半双工总线\n主要用于近距离、低速的芯片之间的通信;\nIIC总线有两根双向的信号线一根数据线SDA用于收发数据，一根时钟线SCL用于通信双方时钟的同步;\nIIC总线硬件结构简单，成本较低，因此在各个领域得到了广泛的应用\nIIC总线是一种多主机总线，连接在IIC总线上的器件分为主机和从机\n主机有权发起和结束一次通信，而从机只能被主机呼叫;\n当总线上有多个主机同时启用总线时，IIC也具备冲突检测和仲裁的功能来防止错误产生;\n每个连接到IIC总线上的器件都有一个唯一的地址(7bit)，且每个器件都可以作为主机也可以作为从机(同一时刻只能有一个主机),总线上的器件增加和删除不影响其他器件正常工作;\n IIC总线在通信时总线上发送数据的器件为发送器，接收数据的器件为接收器;\nIIC总线通信过程\n主机发送起始信号启用总线（其他主机在后面就不会占用总线）\n主机发送一个字节数据（8bit）指明从机地址（7bit）和后续字节的传送方向（1bit）【主机发给从机（0）还是从机发给主机（1）】\n被寻址的从机（各个从机将主机发送的字节高七位地址提取出来与自己的地址比较）发送应答信号回应主机\n发送器（看传送方向确定是主机还是从机）发送一个字节数据\n接收器（看传送方向确定是主机还是从机）发送应答信号回应发送器(循环步骤4、5)\n通信完成后主机发送停止信号释放总线\n\nIIC总线寻址方式IIC总线上传送的数据是广义的，既包括地址，又包括真正的数据\n主机在发送起始信号后必须先发送一个字节的数据，该数据的高7位为从机地址，最低位表示后续字节的传送方向，”0“表示主机发送数据，”1”表示主机接收数据:总线上所有的从机接收到该字节数据后都将这7位地址与自己的地址进行比较，如果相同，则认为自己被主机寻址，然后再根据第8位将自己定为发送器或接收器\n","tags":["通信协议"]},{"title":"初识RTOS","url":"/2023/02/04/%E5%88%9D%E8%AF%86RTOS/","content":"RTOS的简介及分类RTOS，即Real Time Operation System（实时操作系统）。\n常见的RTOS有国外的FreeRTOS、μC&#x2F;OS、RTX和国内的RT-Thread、Huawei LiteOS、AliOS-Things等。\n如何学习RTOS\n利用别人移植好的系统，了解RTOS里面的API使用说明（即各个函数的作用），然后调用这些API实现自己想要的功能（浅薄、简单）\n阅读RTOS的源码，探究内核和每个组件的实现方式（有效、困难）\n\nFreeRTOS简介FreeRTOS是一个可裁剪的小型RTOS系统，其特点包括：\n\nFreeRTOS 的内核支持抢占式（高低优先级任务），合作式和时间片调度。\n\nSafeRTOS （收费）衍生自 FreeRTOS，SafeRTOS 在代码完整性上相比 FreeRTOS更胜一筹。\n\n提供了一个用于低功耗的 Tickless 模式。（将空闲任务闲置的外设时钟关闭）\n\n系统的组件在创建时可以选择动态或者静态的 RAM，比如任务、消息队列、信号量、软件定时器等等\n\n已经在超过 30 种架构的芯片上进行了移植。\n\nFreeRTOS-MPU 支持Corex-M 系列中的 MPU 单元，如 STM32F407。\n\nFreeRTOS 系统简单、小巧、易用，通常情况下内核占用 4k-9k 字节的空间。\n\n高可移植性，代码主要 C 语言编写。\n\n支持实时任务和协程(co-routines 也有称为合作式、协同程序，本教程均成为协程)\n\n任务与任务、任务与中断之间可以使用任务通知、消息队列、二值信号量、数值型信号量、递归互斥信号量和互斥信号量进行通信和同步。\n\n创新的事件组(或者事件标志)。\n\n具有优先级继承特性的互斥信号量。（避免优先级翻转）\n\n高效的软件定时器。（区别于硬件定时器）\n\n强大的跟踪执行功能。\n\n堆栈溢出检测功能。（通过宏定义进行编写，以及利用回调函数【钩子函数】）\n\n任务数量不限。（理论上不限，但实际中受限于我们的ram大小）\n\n任务优先级不限。（理论上不限，但实际中受限于我们的ram大小）\n\n\n如何获取FreeRTOS资源\n在 官网 获取，在里面可以下载其源码及其手册\n\n在托管网址获取\n\n\n","tags":["FreeRTOS"]},{"title":"初识UART","url":"/2023/02/06/%E5%88%9D%E8%AF%86UART/","content":"UART简介UART，即Universal Asynchronous Receiver Transmitter （通用异步收发器）。\n是一种通用的串行、异步通信总线；\n该总线有两条数据线，可以实现全双工的发送和接收；\n在嵌入式系统中常用于主机与辅助设备之间的通信（主控制器和其他芯片或者外围设备通信时使用）\n\nps：\n\n并行通信和串行通信\n并行通信：将数据的多个位一次性发送，比如一个8位数据使用8根线进行传送\n串行通信：将数据的多个位逐次发送，比如一个8位数据使用1根线依次进行传送\n\n单工通信和双工通信\n单工通信：发送器给接收器发送数据，接收器不能给发送器发送数据，单向的\n双工通信：既可以发送器给接收器发送数据，也可以接收器给发送器发送数据，双向的\n半双工：属于双工通信，但是发送数据过程不能同时进行\n全双工：属于双工通信，但是发送数据过程可以同时进行\n\n异步通信和同步通信\n异步通信：收发双方时钟不同步\n同步通信：收发双方使用同一个时钟基准\n\n\n\n波特率波特率用于描述UART通信时的通信速度，其单位为bps(bit per second) ，即每秒钟传送的bit（二进制位）的数量\nUART帧格式空闲位：一直是高电平（即1）\n起始位：第一个低电平位（即0）\n数据位：8位，发送数据时先发送低位，例如：发送0x55（01010101）这个数据时，先发送低位1\n校验位（可有可无）：校验数据的正确性，串口使用奇偶校验（别于和校验），当发送数据有偶数个1时，校验位上为1\n停止位：1位&#x2F;1.5位&#x2F;2位，高电平，表示通信的停止\n通信必须一个字节一个字节发送，每发送一个字节都是一个完整的过程，不能连续发送，防止累计误差的出现\nUART控制器一般情况下处理器中都会集成UART控制器，我们使用UART进行通信时候只需对其内部的相关寄存器进行设置即可\n","tags":["通信协议"]},{"title":"Hello World","url":"/2023/01/11/hello-world/","content":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub.\nQuick StartCreate a new post$ hexo new &quot;My New Post&quot;\n\nMore info: Writing\nRun server$ hexo server\n\nMore info: Server\nGenerate static files$ hexo generate\n\nMore info: Generating\nDeploy to remote sites$ hexo deploy\n\nMore info: Deployment\n","tags":["test"]}]